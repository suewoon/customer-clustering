# Customer Clustering 

- e-commerce 분석에 가장 기초가 되는 transaction data 를 바탕으로, customer-level의 dimension table을 만들고, 
고객 기준으로 K-means Cluster Analysis 수행
- input dataset이 될 customer-level table에는 아래와 같은 column들이 들어 갈 수 있다. '3. 선택한 상품'과 같은 경우,
선택할 수 있는 총 상품(#SKU)이 약 2600개이므로 dimension reduction이 필요 
  - 1. 상품 구매 금액, 횟수, 주기
  - 2. 지출 금액대
  - 3. 선택한 상품
- `sklearn.decomposition.PCA` 사용하여 dimensionality reduction을 함

## 1. Load Libraries & Dataset Exploration
- `Kaggle Datasets`에서 제공된 데이터 셋 사용([다운로드](https://www.kaggle.com/carrie1/ecommerce-data/data))
- 필요한 library와 제공된 dataset을 load하고 각 column들에 대해 간단한 통계정보를 알아 봄

## 2. Data Cleaning & Wrangling
- 주어진 dataset이 transaction based(한 row에 하나의 주문 번호, 상품번호, 구매 갯수, 고객번호)이므로 고객이 구매한 상품을 기준으로 clustering 하려면 transaction-level -> customer-level로 테이블을 변형해야 함
- transaction-level을 fact table이라고 하고 customer-level을 customer dimension table이라고 함
### 2-1. Fact Table 
- 각 feature의 분포 확인, null값이 있는 row처리 
<a name='2-2'></a>
### 2-2. Customer Dimension Table
- transaction 데이터를 고객 중심으로 보기 위해서 아래와 같은 feature를 만듬
  - 고객별 주문 횟수
  - 고객별 상품 주문 수, SKU 주문 수
  - 고객별 매출 총합, 평균
  - 고객별 basket size 최소, 최대, 평균
  
## 3. Dimension Reduction using PCA
- [2-2. Customer Dimension Table](#2-2)에서 customer-level에 일반적으로 고객을 평가 할 수 있는 feature를 만들었다. 이에 더해 고객들이 어떤 상품을 샀는지를 바탕으로 cluster하기 위해서, 
우선 상품 하나하나가 column이 되도록 one-hot encoding을 한다. 상품이 2600개 정도 되기 때문에 PCA()를 이용해서, 
total variance를 잘 설명할 수 있는 주 성분만 뽑는다 -> 차원 축소
  - 상품에 대해 one-hot encoding
  - StandardScaler()로 feature value 스케일 조정
  - PCA()로 explained variance가 높은 feature만 뽑아옴
  
## 4. Clustering
- cluster analysis를 수행 할 때, dataset 두 가지를 넣어 볼 수 있음
  - 1. customer-level table 
  - 2. customer-level table + new features generated by PCA 
- clustering의 경우 unsupervised learning으로 알고리즘의 performance를 측정할 metric이 정의되어있지 않기 때문에, 서로 다른 데이터셋이나 알고리즘으로 나온 
cluster결과를 비교해서 그 결과가 얼마나 비슷한지/다른지를 알아봄
### 4-1. K-Means clustering
- `sklearn.clustering.KMeans`에 4가지 cluster로 고객을 나누고 그래프로 표시
### 4-2. Model comparison
- unsupervised learning에서 performance metric이 정해져 있지 않으므로 `sklearn.metrics.adjusted_rand_score`로 서로 다른 두 clustering result를 비교 
